package main

import (
	"context"
	"fmt"
	"net"
	"net/http"

	"golang.org/x/net/http2"
	"golang.org/x/net/http2/h2c"

	"google.golang.org/grpc"

	myErr "amiame/test-cockroachdb-errors/error"
	greetv1 "amiame/test-cockroachdb-errors/gen/greet/v1" // generated by protoc-gen-go and protoc-gen-go-grpc
	"amiame/test-cockroachdb-errors/server/package1"

	//"github.com/cockroachdb/errors"
	"github.com/cockroachdb/errors/grpc/middleware"
	"github.com/cockroachdb/errors/report"
)

type GreetServer struct {
	greetv1.UnimplementedGreetServiceServer
}

func (s *GreetServer) Greet(_ context.Context, req *greetv1.GreetRequest) (*greetv1.GreetResponse, error) {
	/*
		res := &greetv1.GreetResponse{
			Greeting: fmt.Sprintf("Hello, %s!", req.Name),
		}
		return res, nil
	*/
	if err := package1.Func1(); err != nil {
		evt, dtls := report.BuildSentryReport(err)
		for k, v := range dtls {
			fmt.Printf("%s--> %s\n", k, v)
		}
		fmt.Printf("evt: %v\n", evt)
		fmt.Printf("%+v\n", err)
		return nil, err
	}
	return nil, myErr.Error3
}

func main() {
	// TCP settings
	lis, err := net.Listen("tcp", ":50052")
	if err != nil {
		panic(err)
	}

	// Pass our handler and an instance of the gRPC server to the generated function
	greeter := &GreetServer{}
	grpcServer := grpc.NewServer(grpc.UnaryInterceptor(middleware.UnaryServerInterceptor))
	greetv1.RegisterGreetServiceServer(grpcServer, greeter)
	if err := grpcServer.Serve(lis); err != nil {
		panic(err)
	}

	// HTTP settings
	h2s := &http2.Server{} // Use h2c so we can serve HTTP/2 without TLS.
	handler := h2c.NewHandler(grpcServer, h2s)
	mux := http.NewServeMux()
	mux.Handle("/greet.v1.GreetService/", handler)

	// Serve
	if err := http.Serve(lis, mux); err != nil {
		panic(err)
	}
}
